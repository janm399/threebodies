---
layout: post
title:  "ESP-IDF 2：固件基础设置"
date:   2019-11-06 17:00:00 +0000
categories: [HW, SW]
excerpt: "sss"
hidden: true
---
古典“blink”项目我们探索于下一个帖子，现在我们来加上一个按钮，让把按钮控制在`BLINK_GPIO`接上的LED：如果LED在发光的状态，接下来把按钮按下会让它不发光，反之亦然。如下电路图所示，我们只加上一个按钮。

![包括按钮的电路](/assets/2019-11-06-esp-idf-2/button-sch.png){:class="img-responsive"}

随着上面的电路图，我们首先需要设置`GPIO_NUM_17`于输入脚，其中在`app_main`中的无限循环里每一个重复从`GPIO_NUM_17`读目前逻辑值。因为按钮是接上0V，按下是`GPIO_NUM_17`的逻辑值会等于`false`，如果不按下—也就是说`GPIO_NUM_17`没有任何电链接时—按照逻辑IC规则，逻辑值是不一定的。为了让输入脚的逻辑值一定的，我们需要加上所谓上拉电阻器。好在ESP32里每一个GPIO脚都包括内置、可配置的上拉电阻器，只有输入脚被设置好，才能靠内置上拉电阻器以让它的逻辑值一定的。

{% highlight C++ linenos %}
// 保存在$PROJECT_ROOT/src/main.cpp

#include <driver/gpio.h>
#include <freertos/FreeRTOS.h>
#include <freertos/task.h>
#include "sdkconfig.h"

#define BLINK_GPIO GPIO_NUM_5
#define BUTTON_GPIO GPIO_NUM_17

extern "C" void app_main(void) {
  gpio_pad_select_gpio(BLINK_GPIO);
  gpio_set_direction(BLINK_GPIO, GPIO_MODE_OUTPUT);

  gpio_pad_select_gpio(BUTTON_GPIO);
  gpio_set_direction(BUTTON_GPIO, GPIO_MODE_INPUT);
  gpio_set_pull_mode(BUTTON_GPIO, GPIO_PULLUP_ONLY);

  ...
}
{% endhighlight %}

随着上面的源码，执行到行17后，我们可以调用`gpio_get_level`以读`GPIO_NUM_17`输入脚的目前的逻辑值。好像加上前面提到的`gpio_get_level`即可。

{% highlight C++ linenos %}
extern "C" void app_main(void) {
  
  bool light = false;
  while (1) {
    if (gpio_get_level(BUTTON_GPIO) == 0) {
      light = !light;
      gpio_set_level(BLINK_GPIO, light);
    }
  }
}
{% endhighlight %}

执行上面的代码会出两个问题：则被`task_wdt`（什么鬼？！）引起的自动重启，则好像LED一达到发光的状态不再达到不发光的。为了办理第一个问题，要知道什么是WDT？其实，WDT是一种自动计时器，处理器会每一个时钟脉冲把WDT加成1，WDT一达到一定值，处理器就被自动重启了。解决其实很简单，我们只需要适时把WDT复位，因此每一个重复都调用`esp_task_wdt_init(portMAX_DELAY, false)`即可。第二个问题的原因更复杂，首先要调查为什么读输入中的逻辑值是这么不稳定的。

{% highlight C++ linenos %}
extern "C" void app_main(void) {
  esp_task_wdt_init(portMAX_DELAY, false);
  bool light = false;
  while (1) {
    ...
  }
}
{% endhighlight %}

可是问题还在，虽然按键被按下了，但`gpio_get_level(BUTTON_GPIO)` **偶尔**返回`1`！另外，`gpio_get_level()`稳不稳定看似随着按键被按下了多长时间。被按下了短时间，`gpio_get_level()`非常不稳定，被按下了比较长时间，`gpio_get_level()`更稳定，不过还并不是稳定的。怎么回事？按键被按下了时我们需要量电压平，于被按下很短时间开始，如下两个视频所示。

<div class="myvideo">
   <video  style="display:block; width:100%; height:auto;" autoplay controls loop="loop">
       <source src="{{ site.baseurl }}/assets/2019-11-06-esp-idf-2/24ms.mp4" type="video/mp4" />
   </video>
</div>

<div class="myvideo">
   <video  style="display:block; width:100%; height:auto;" autoplay controls loop="loop">
       <source src="{{ site.baseurl }}/assets/2019-11-06-esp-idf-2/240ms.mp4" type="video/mp4" />
   </video>
</div>

为了发现`gpio_get_level()`这么不稳定，首先要发现如下`while`无限循环里每一个循环需要都长时间。如下代码包含一种时间测量代码，即每一个循环重复需要多长时间。

{% highlight C++ linenos %}
  bool light = false;
  bool x = false;
  esp_task_wdt_init(portMAX_DELAY, false);
  while (1) {
    gpio_set_level(CLK_GPIO, x);
    x = !x;
    if (gpio_get_level(BUTTON_GPIO) == 0) {
      light = !light;
    }
  }
{% endhighlight %}

测量仪器写完后，我们可以使用示波镜来探索按键被按下的时候MCU从`BUTTON_GPIO`输入脚读什么样的值。

![下降沿](/assets/2019-11-06-esp-idf-2/mu.png){:class="img-responsive"}
![上升沿](/assets/2019-11-06-esp-idf-2/md-get.png){:class="img-responsive"}

如上面的两张示波镜图所示是两个信号：紫色是测量仪器信号，黄色是按键输入脚信号。随着示波镜图问题很简单理解的：MCU的频率太高了，按照下面的代码，MCU每450ns—450纳秒！这么短一阵时间—调用`gpio_get_level()`。只要我们每一个重复调用`vTaskDelay(pdMS_TO_TICKS(50))`为了使循环减速点。

![下降沿](/assets/2019-11-06-esp-idf-2/slow.png){:class="img-responsive"}

这样做我们一定遇到另一个问题：

250 ns per loop

从如上示波镜图所示，我们发现利用`gpio_get_level()`以读按键状态随着MCU时钟源、即它的频率。不适时调用`gpio_get_level()`会让它返回“不对”值，

