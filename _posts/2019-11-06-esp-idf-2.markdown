---
layout: post
title:  "ESP-IDF 2：固件基础设置"
date:   2019-11-06 17:00:00 +0000
categories: [HW, SW]
excerpt: "sss"
---
古典“blink”项目我们上个帖子中探索过，现在我们来加上一个按键，让它控制在`BLINK_GPIO`接上的LED：当LED发光时（即`LED_GPIO`输出在高电平状态），把按键按下会让它不发光；当LED不发光，把按键按下会让它发光：这么简单。

ESP32有34个物理GPIO脚，其中GPIO 34-39仅用作输入管脚，其他的可以作为输入又可以作为输出管脚。接上按键需要输入脚，因此，我们只要选择随便GPIO输入即可。总之，我们需要于`app_main`函数里再调用`gpio_get_level`为了读取接上于按键的GPIO输入电平状态。这个读取电平必须要是决定的，这就是说按键不被按下时输入读取的电平必须是低的；按键被按下时输入读取的电平必须是高的。那么，当不被按下时高电平、当被按下时低电平不是随便选择的：ESP32中的输入脚包含内部上拉电阻器，结果如下电路图。

![内部上拉电阻器](/assets/2019-11-06-esp-idf-2/plain-button-sch.png)

这个内部电阻器保证从`BUTTON_GPIO`读取的电平是决定的，注意，这种保证会消耗$$73.3μA，241.89μW$$。不过，为了保证输入稳定性确实没有其他办法。接下来，我们看如下电路图所示如何把按键接到ESP32的输入脚上。

![包括按钮的电路](/assets/2019-11-06-esp-idf-2/esp32-button-plain-sch.png)

## Busy wait 循环实现

随着上面的电路图，我们首先需要设置`GPIO_NUM_17`为输入脚，其中在`app_main`中的无限循环里每一个重复从`GPIO_NUM_17`读取目前的电平。按键不被按下时内部上拉电阻器使输入脚变高，同时没有任何废消耗电流；只按钮被按下时，使输入脚的电平变低，也引起从VCC到GND流行废电流消耗$$73.3μA$$。如已设置到的`BLINK_GPIO`输出，我们首先要通过调用`gpio_set_direction`、`gpio_set_pull_mode`来设置`BUTTON_GPIO`输入脚的属性。

{% highlight C++ linenos %}
// 保存在$PROJECT_ROOT/src/main.cpp

#include <driver/gpio.h>
#include <freertos/FreeRTOS.h>
#include <freertos/task.h>
#include "sdkconfig.h"

#define BLINK_GPIO GPIO_NUM_5
#define BUTTON_GPIO GPIO_NUM_17

extern "C" void app_main(void) {
  gpio_pad_select_gpio(BLINK_GPIO);
  gpio_set_direction(BLINK_GPIO, GPIO_MODE_OUTPUT);

  gpio_pad_select_gpio(BUTTON_GPIO);
  gpio_set_direction(BUTTON_GPIO, GPIO_MODE_INPUT);
  gpio_set_pull_mode(BUTTON_GPIO, GPIO_PULLUP_ONLY);

  ...
}
{% endhighlight %}

既然上面的示例把`BUTTON_GPIO`输入设置好了，执行到行17后，我们可以调用`gpio_get_level`以读取于`GPIO_NUM_17`的电平。

{% highlight C++ linenos %}
extern "C" void app_main(void) {
  
  bool light = false;
  while (1) {
    if (gpio_get_level(BUTTON_GPIO) == 0) {
      light = !light;
      gpio_set_level(BLINK_GPIO, light);
    }
  }
}
{% endhighlight %}

在`app_main`放的无限循环会引起两个问题：则被`task_wdt`（什么鬼？！）引起的MCU自动重启，则好像LED一达到发光的状态不再达到不发光的。为了办理第一个问题，先要知道什么是WDT。原则上WDT是一种自动计时器，处理器会每一个时钟脉冲把WDT加成1，WDT一达到一定值，处理器就被自动重启了。更仔细地探索，在默认设置下，FreeRTOS管理的每一个属于任务的WDT，任务的WDT一旦达到一定值，就FreeRTOS会调用所谓紧急处理程序。这个紧急处理程序是一个最后执行的函数，FreeRTOS包括[几种紧急处理程序](https://docs.espressif.com/projects/esp-idf/zh_CN/latest/api-guides/fatal-errors.html)。为了WDT问题简单得解，调用`esp_task_wdt_init(portMAX_DELAY, false)`即可。第二个问题的原因更复杂，首先要调查为什么读取输入脚的电平虽然是利用上拉电阻器，但还这么不稳定。

{% highlight C++ linenos %}
extern "C" void app_main(void) {
  esp_task_wdt_init(portMAX_DELAY, false);
  bool light = false;
  while (1) {
    ...
  }
}
{% endhighlight %}

可是问题还在，虽然按键被按下了，但`gpio_get_level(BUTTON_GPIO)` **偶尔**返回`1`！另外，`gpio_get_level()`稳不稳定看似随着按键被按下了多长时间。被按下了很短时间，`gpio_get_level()`非常不稳定，被按下了比较长时间，`gpio_get_level()`更稳定，只不过还不算是稳定的。怎么回事？

<div class="myvideo">
   <video  style="display:block; width:100%; height:auto;" controls loop="false">
       <source src="{{ site.baseurl }}/assets/2019-11-06-esp-idf-2/24ms.mp4" type="video/mp4" />
   </video>
</div>

<div class="myvideo">
   <video  style="display:block; width:100%; height:auto;" controls loop="false">
       <source src="{{ site.baseurl }}/assets/2019-11-06-esp-idf-2/240ms.mp4" type="video/mp4" />
   </video>
</div>

为了探索为什么`gpio_get_level()`这么不稳定，首先要探索如下`while`无限循环每一个重复需要多长时间。如下示列包含时间测量代码，每一个重复会把`CLK_GPIO`输出发的电平交替。简单来考虑处理器时钟效率不足够：虽然考虑处理器时钟效率会告诉我们每一个机器指令需要多长时间，但执行输入、输出函数并装不下一个机器指令。

{% highlight C++ linenos %}
  bool light = false;
  bool x = false;
  esp_task_wdt_init(portMAX_DELAY, false);
  while (1) {
    gpio_set_level(CLK_GPIO, x);
    x = !x;
    if (gpio_get_level(BUTTON_GPIO) == 0) {
      light = !light;
    }
  }
{% endhighlight %}

写完这种仪器仪表，我们可以使用示波镜来探索`app_main`中的无限循环是如何执行的，尤其探索每一个“指令”，每一个行需要都长时间。当然，我们正确得估计如`x = !x`, `light = !light`相比，调用执行I/O的函数需要的时间几数量级长。然而，这个简单方式为了了解我们遇到的问题足够了。下面的两个示波镜图所示两个信号：紫色是仪器仪表信号（即每一个无限循环重复交替到`CLK_GPIO`输出），黄色是按键输入脚信号。

![上升沿](/assets/2019-11-06-esp-idf-2/bu.png)

上面的一张示波镜图所示每$$540ns$$重复的无限循环，并且所示按键被按下时的电信号。如可以看到，按键被按下引起的电平变低要$$\approx500ns$$的时间，而且在$$\approx500ns$$内的电平变化看似稳定。

![下降沿](/assets/2019-11-06-esp-idf-2/bd.png)

从第二张示波镜图可以看到按键被松开后引起什么样的电平曲线。如被按下时相比，被松开引起的曲线需要更长时间为了从$$0$$达到$$VCC$$电平，以致在几个重复内读取的电平可能是不决定的：注意，电平$$(0,\frac{1}{4}VDD)$$相当于逻辑值0或者`false`，电平$$(\frac{3}{4}VCC,VCC)$$相当于逻辑值1或者`true`，其他电平值是不一定的。

没有人可以察觉$$540ns$$这么短时间，调用一个耽误执行的函数即可。问题来了：最适合耽误的时间是多少？原来一般用户以超过\approx50ms的耽误为不可接受：提醒你们最低电影帧率不小于$$20Hz$$。按照这种想法，好像很适合耽误相当于$$50ms$$，因此就调用`vTaskDelay(pdMS_TO_TICKS(50))`来把循环“速度”耽误于$$50ms$$即可。

{% highlight C++ linenos %}
  bool light = false;
  bool x = false;
  esp_task_wdt_init(portMAX_DELAY, false);
  while (1) {
    gpio_set_level(CLK_GPIO, x);
    x = !x;
    if (gpio_get_level(BUTTON_GPIO) == 0) {
      light = !light;
      gpio_set_level(BLINK_GPIO, light);
    }
    vTaskDelay(pdMS_TO_TICKS(50));
  }
{% endhighlight %}

这样做我们一定遇到另一个问题。如下面的视频所示，如果用户把按按下得类似于很快地轻拍，由于这种非常快--即很短时间内进行的--轻拍结果非常短电平变化。

<div class="myvideo">
   <video  style="display:block; width:100%; height:auto;" controls loop="false">
       <source src="{{ site.baseurl }}/assets/2019-11-06-esp-idf-2/50ms.mp4" type="video/mp4" />
   </video>
</div>

如下两张示波镜图所示这种快轻拍：黄色`BUTTON_GPIO`中电平曲线，它的电平相当于低只有$$\approx18ms$$的时间。再加，如果我们把`app_main`中代码放在示波镜图的上面，就很容易地发现问题在哪里。

![下降沿](/assets/2019-11-06-esp-idf-2/slow-1a.png)
![下降沿](/assets/2019-11-06-esp-idf-2/slow-1b.png)

请注意，上面的两张示波镜图上的时基相当于$$10ms/div$$，除了`vTaskDelay`以外，本来代码还要本来的一段时间，即$$540ns$$！因此，上张示波镜图并不确切；只有我们考虑示波镜图的时基相当于$$10ms$$、只有我们考虑`vTaskDelay`跟本来代码的执行时间区别，才能得到正确执行安排，如下面图片所示。

![下降沿](/assets/2019-11-06-esp-idf-2/slow-1c.png)

跟着上示波镜图所示的执行顺序，看似取样定理中所谓“混叠”问题。简单来说，按键按下的效率比取样效率低多了（循环进行的时间相当于$$T\approx50ms; f\approx20Hz$$相对于按键被按下的时间相当于只$$T\approx18ms; f\approx55Hz$$），以致`gpio_get_level`偶尔读取对用户来说不对的电平值。有一种跟着取样定理的解决办法：把取样效率增加到至少$$2f$$，因此把`vTaskDelay`参数减少到$$18ms/2=9ms$$或者$$T\approx18ms; f\approx55Hz, 2f\approx110Hz; 2T\approx9ms$$。目前`app_main`的无限循环里有这么简单代码，因此我们很容易得考虑它的执行顺序和间隔。代码越来越复杂会让这种理性也越来越复杂，最终我们会认识到这类处理输入的方式完全不满意。我们需要寻找另一个方式，靠不一样基本的方式。

## 中断实现
在无限循环办理I/O？？？更合适办法是利用中断的，处理器一接到中断会把目前执行的任务停止，接下来进行中断处理程序；程序进行完后，处理器会再继续进行以前停止的过程。当然，当一个处理中断程序进行着，另一个处理终端程序可以把它停止、代替，为了决定哪一个中断程序应该进行，处理器/操作系统使用中断处理程序的优先。ESP32支持

![下降沿](/assets/2019-11-06-esp-idf-2/intr-nice.png)

<div class="myvideo">
   <video  style="display:block; width:100%; height:auto;" controls loop="false">
       <source src="{{ site.baseurl }}/assets/2019-11-06-esp-idf-2/intr-bounce.mp4" type="video/mp4" />
   </video>
</div>

![下降沿](/assets/2019-11-06-esp-idf-2/intr-bounce.png)
![下降沿](/assets/2019-11-06-esp-idf-2/intr-debounce.png)

{% highlight C++ linenos %}
#include <driver/gpio.h>
#include <esp_task_wdt.h>
#include <freertos/FreeRTOS.h>
#include <freertos/queue.h>
#include <freertos/semphr.h>
#include <freertos/task.h>
#include <math.h>
#include "sdkconfig.h"

#define MIN_DELAY 500
#define BUTTON_GPIO GPIO_NUM_17
#define BLINK_GPIO GPIO_NUM_5

static xSemaphoreHandle semaphore_handle = nullptr;

void led_task(void* arg) {
  bool x = false;
  while (true) {
    xSemaphoreTake(semaphore_handle, portMAX_DELAY);
    x = !x;
    gpio_set_level(BLINK_GPIO, x);
  }
}

void IRAM_ATTR button_isr_handler(void* arg) {
  static auto last_time = 0;
  auto now = xTaskGetTickCountFromISR();
  if (now - last_time > MIN_DELAY) {
    auto ignored = pdFALSE;
    xSemaphoreGiveFromISR(semaphore_handle, &ignored);
    last_time = now;
  }
}

extern "C" void app_main(void) {
  gpio_pad_select_gpio(BLINK_GPIO);
  gpio_set_direction(BLINK_GPIO, GPIO_MODE_OUTPUT);

  gpio_pad_select_gpio(BUTTON_GPIO);
  gpio_set_direction(BUTTON_GPIO, GPIO_MODE_INPUT);
  gpio_set_pull_mode(BUTTON_GPIO, GPIO_PULLUP_ONLY);
  gpio_set_intr_type(BUTTON_GPIO, GPIO_INTR_NEGEDGE);

  semaphore_handle = xSemaphoreCreateBinary();
  xTaskCreate(led_task, "led_task", 2048, NULL, 10, NULL);
  gpio_install_isr_service(ESP_INTR_FLAG_LEVEL1);
  gpio_isr_handler_add(BUTTON_GPIO, button_isr_handler, nullptr);
}
{% endhighlight %}