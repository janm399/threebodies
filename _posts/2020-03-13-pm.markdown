---
layout: post
title:  "函数式到底好不好用？"
date:   2020-03-13 15:00:00 +0000
categories: [SW]
excerpt: "case class"
hidden: true
---
# Scala教程第一课：case class和模式匹配 （pattern matching）
本文章所讨论的是最常见的数据结构体，特别是在Java虚拟机，这就意味着我们会谈怎么最好，最方便地定义适应数据结构体的对象。那么，对象意味着JVM中的数据结构体并不是零代价抽象，除结构体中的所有字段之外，每一个对象都有自己的代价，这恐怕是JVM的基本设计。

## 避免单调、重复的代码
既然JVM没有零代价抽象，我们也不能放弃所有的可靠，可维持的代码规则。其中有最大影响是不可变性，不可变的，也就是说只读的，值在多线程的环境下能够安全地计算。最好从一个简单例子开始吧，下面的代码所示是Java做法来完全只读的结构体。

{% highlight Java %}
class User {
    private Long id;
    private String username;

    User(Long id, String username) {
        this.id = id;
        this.username = username;
    }

    public Long getId() { return id; }
    public String getUsername() { return username; }
}
{% endhighlight %}

该`User`实例的确是不可变的，只读的值；一旦构造器执行完，它产生的值便无法被改变了。如果你负责将代码评价，你一定会发一些建议。

* 构造器允许`User`中的字段`id`、`username`赋值于`null`
* 该类型完全缺乏`hashCode`，`equals`
* 虽然不必要的，但`User`还缺乏适应`toString`实现

我们编写下去，终于得到下面的代码。

{% highlight Java linenos %}
class User {
    private Long id;
    private String username;

    User(Long id, String username) {
        if (id == null) throw new IllegalArgumentException("...");
        if (username == null) throw new IllegalArgumentException("...");

        this.id = id;
        this.username = username;
    }

    public Long getId() { return id; }
    public String getUsername() { return username; }

    @Override 
    public boolean equals(Object o) {
        if (o instanceof User) {
            User that = (User)o;
            return this.id.equals(that.id) &&
                   this.username.equals(that.username);
        } else return false;
    }

    @Override 
    public int hashCode() {
        //
    }

    @Override 
    public String toString() {
        //
    }
}
{% endhighlight %}

我的天！为了正确地包起来两个字段必须编写三十多行源码，而且最讨厌的是大部分是完全单调的、重复的。不必说，许多IDE能够自我产生其源码，开发者却还需要将产生代码阅读，维修。

最简单模式匹配类似于Java的`instanceof`判断，如果`a instanceof X`判断是满意的，那意味着变量`a`便是一个属于`X`类型的实例。于是，我们能将它投影（cast）到`X`类型时不会遭遇`ClassCastException`异常。因此，常见的Java代码便是随着该逻辑。

{% highlight Java %}
class X {
    private int a;

    @Override
    public boolean equals(Object o) {
        if (o instanceof X) {
            X that = (X)o;
            return this.a == that.a;
        } else return false;
    }
}
{% endhighlight %}

许多开发者觉得如上面的代码不简洁，虽然各种IDE会自动产生这样的代码，但是如果我们后来做一些修改，我们不得不要么再让IDE产生该`equals`，要么手动地修改。那么，利用Scala来实现一样的代码如何？

{% highlight Scala %}
class X {
  private var a: Int

  override def equals(o: AnyRef): Boolean = o match {
    case that: X => that.a == this.a
    case _       => false
  }

}
{% endhighlight %}

`match`关键词指着式匹配的词句，`match`里面有至少一个模式，每一个模式都由`case`开头，随着`case`有具体的模式词句。上面代码使用最基本的，跟`instanceof`一样的功能。关注不仅仅`case`的右边可以直接指左边定义的`that`变量，而且`that`的类型便是`X`。这里要提及另外一个JVM的编程语言：[Kotlin](https://kotlinlang.org/docs/reference/typecasts.html)[^1]。

说到这里，这是最基本模式匹配的能力，接下来我们专心于Scala和Haskell来表示模式匹配最高阶的应用。

## 简洁定义数据的结构体
上面的`X`类型看似一种数据容器，该容器说不定是从REST接口解码的或从数据库读取的；无论如何，常用类似容器包含更多字段。那么，众所周知，应该用不可变的数据结构体，这不仅仅意味着所有的字段只有getters，而且所有的字段需要实例构造时被赋值。字段越多手动实现越麻烦；好在为了简化该常见的任务Scala提供`case class`的概念。基本上，`case class`是一般`class`，可是Scala编译器自我提供相关每一个字段的getter，以及自我实现`equals`、`hashCode`、`toString`。

{% highlight Scala %}
case class Container(name: String, age: Int)
{% endhighlight %}

实例

## 高级模型匹配
回想我们以前所定义的`Container`类，假设你想自己实现它的`equals`方法。

{% highlight Scala %}
case class Container(name: String, age: Int) {
  override lazy val toString: String = s"Container(name=$name, age=$age)"

  override def equals(o: AnyRef): Boolean = o match {
    case Container(`name`, a) if a > age => true
    case _                               => false
  }
}
{% endhighlight %}

----

[^1] [Kotlin](https://kotlinlang.org/docs/reference/typecasts.html)