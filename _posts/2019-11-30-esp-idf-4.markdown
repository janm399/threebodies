---
layout: post
title:  "ESP-IDF 4：使用RMT来实现2812驱动程序"
date:   2019-11-25 18:00:00 +0000
categories: [HW, SW]
excerpt: "******"
hidden: true
---
使用GPIO非常不好用，而且依靠仔细数的`nop`命令为了实现延时精确一段时间一点也不稳定。其他任务、其他编译器的选择、其他芯片版，其实任何好像无足轻重的细节可能会影响该忙碌循环。怎么办?——ESP32基本上是个硬件元件，它一定包括支持这么简单协议的内部电路。

# 红外遥控协议

## ESP32 RMT支持
好像红外遥控协议跟2812协议差不多，而ESP32包含一种通常使用、简单串行协议；这里简单的意思是除非起始或者复位信号，接下来的信号只装下数据。

# 利用RMT以现实2812协议
使用RMT的代码包含两个基础概念：第一个是RMT端口的设置函数和结构体，第二个是把信号变换和传输函数和结构体。如下面源码所示，把RMT端口设置后，只剩下把我们已使用的`rgb_t`结构体变化成传送的函数的参数类型。

## 接口设计
最初接口设计可能随着已实现的两个函数，即类似于“起始/启动”的函数与“传送数据/颜色”的函数。

{% highlight c++ linenos %}
void ws2812_rmt_init(const gpio_num_t gpio);
void ws2812_rmt_set(const rgb_t *items, const uint count);
{% endhighlight %}

使用方法跟已存在的函数完全一样；但既然我们来探索新实现方式，我们就可以考虑一下如何使用现代C++功能，因此我们会把一般指针代替`std::vector`。从该函数（的类型！）可以看出该函数无法控制两个（或者更多）2812元件：虽然我们还没考虑其两个函数中的代码，从它们的参数类型，从它们的返回类型可以推理下面所示的代码只支持唯一个输出，唯一个所谓RMT channel。把其两个函数实现前，最好把接口改变一下，如下面源码所示。

{% highlight c++ linenos %}
class ws2812_rmt {
 private:s
  rmt_channel_t channel;

 public:
  ws2812_rmt(const gpio_num_t gpio, 
             const rmt_channel_t channel = RMT_CHANNEL_0,
             const uint8_t mem_block_num = 1);
  void operator<<(const std::vector<rgb_t> &items) const;
};
{% endhighlight %}

虽然该对象的使用方法真太简单了，随着一般C++方式我们难免写像下面的代码。

{% highlight c++ linenos %}
ws2812_rmt ws2812(LED_STRIP_GPIO);
std::vector<rgb_t> pixels(8);
...
ws2812 << pixels;
{% endhighlight %}

## ws2812_rmt实现
一开始我们应该再回顾下帖子中的2812协议图：重点是则复位信号是$$50us$$长的低电平信号，则颜色信号是24个“1”或者“1”信号。

![2812数据传输1](/assets/2019-11-25-esp-idf-3/led-1.png)
![2812数据传输2](/assets/2019-11-25-esp-idf-3/led-n.png)

# 下一次
下一次，我们来探索如何利用（硬件）串行接口为了建构一个包含GSM配件的项目，该项目是被一般（古老，我们知道！）短信控制的。同时去买一个SIM卡把，再加考虑是否你有适合电源：我们会使用SIM 800L元件，可是它需要提供$$3.7-4.0V @ 2A$$的电源！基本上有两个选择：要么加上一个独立GSM元件，然后使用一个buck变换器（linear变换器的效率很低，因此它们不会提供这么高电流），要么把ESP32换成一个USB-C、包含SIM元件的。
