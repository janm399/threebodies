---
layout: post
title:  "ESP-IDF 4：使用RMT来实现2812驱动程序"
date:   2019-11-25 18:00:00 +0000
categories: [HW, SW]
excerpt: "******"
hidden: true
---
使用GPIO非常不好用，而且依靠仔细数的`nop`命令为了实现延时精确一段时间一点也不稳定。其他任务、其他编译器的选择、其他芯片版，其实任何好像无足轻重的细节可能会影响该忙碌循环。怎么办?——ESP32基本上是个硬件元件，它一定包括支持这么简单协议的内部电路。

# 红外遥控协议

## ESP32 RMT支持
好像红外遥控协议跟2812协议差不多，而ESP32包含一种通常使用、简单串行协议；这里简单的意思是除非起始或者复位信号，接下来的信号只装下数据。

# 利用RMT以现实2812协议
使用RMT的代码包含两个基础概念：第一个是RMT端口的设置函数和结构体，第二个是把信号变换和传输函数和结构体。如下面源码所示，把RMT端口设置后，只剩下把我们已使用的`rgb_t`结构体变化成传送的函数的参数类型。

## 接口设计
最初接口设计可能随着已实现的两个函数，即类似于“起始/启动”的函数与“传送数据/颜色”的函数。

{% highlight c++ linenos %}
void ws2812_rmt_init(const gpio_num_t gpio);
void ws2812_rmt_set(const rgb_t *items, const uint count);
{% endhighlight %}

使用方法跟已存在的函数完全一样；但既然我们来探索新实现方式，我们就可以考虑一下如何使用现代C++功能，因此我们会把一般指针代替`std::vector`。从该函数（的类型！）可以看出该函数无法控制两个（或者更多）2812元件：虽然我们还没考虑其两个函数中的代码，但从它们的参数类型、从它们的返回类型可以推理下面所示的代码只支持唯一个输出，唯一个所谓RMT channel。实现其两个函数之前，最好把接口改变一下，如下面源码所示。

{% highlight c++ linenos %}
class ws2812_rmt {
 private:s
  rmt_channel_t channel;

 public:
  ws2812_rmt(const gpio_num_t gpio, 
             const rmt_channel_t channel = RMT_CHANNEL_0,
             const uint8_t mem_block_num = 1);
  void operator<<(const std::vector<rgb_t> &items) const;
};
{% endhighlight %}

虽然该对象的使用方法真太简单了，随着一般C++方式我们难免写像下面的代码。

{% highlight c++ linenos %}
ws2812_rmt ws2812(LED_STRIP_GPIO);
std::vector<rgb_t> pixels(8);
...
ws2812 << pixels;
{% endhighlight %}

## ws2812_rmt实现
一开始我们应该再回顾下帖子中的2812协议图：重点是则复位信号是$$50μs$$长的低电平信号，则颜色信号是24个“1”或者“1”信号。

![2812数据传输1](/assets/2019-11-25-esp-idf-3/led-1.svg)
![2812数据传输2](/assets/2019-11-25-esp-idf-3/led-n.svg)

本来我们靠`nop`的执行时间与时钟源的频率；回顾我们算法：每一个时钟同期要$$1/240MHz = 4.16ns$$；因此，已实现延时$$125ns$$的函数，我们需要调用30个`nop`机器指令即可。最终我们成功了，可是我们最好再仔细地检查信号的时间分布。RMT也必须要跟着某个时钟源，不仅如此也必须靠某个管理时间的模块。区别来自于他的实现细节，尤其它不仅仅依靠独立时钟源，而且它的传送是靠硬件的。所以，虽然我们还需要算一算一些参数，但算好后RMT模块会自我管理数据传输的过程。

为了算好RMT的参数只需要知道RMT时钟源的频率，即$$80MHz$$；这使时钟同期$$f=80MHz \Rightarrow T=12.5ns$$，从而延时$$125ns$$和$$1000ns$$的时间，分别要设置10个和80个时钟同期。

{% highlight c++ linenos %}
static constexpr const uint32_t ds = 10;
static constexpr const uint32_t dl = 80;

ws2812_rmt::ws2812_rmt(const gpio_num_t gpio, 
                       const rmt_channel_t channel,
                       const uint8_t mem_block_num) {
  rmt_config_t config;
  config.rmt_mode = RMT_MODE_TX;

  config.channel = channel;
  config.gpio_num = gpio;
  config.mem_block_num = mem_block_num;
  config.clk_div = 1;

  config.tx_config.loop_en = false;
  config.tx_config.carrier_en = false;
  config.tx_config.idle_output_en = true;
  config.tx_config.idle_level = RMT_IDLE_LEVEL_LOW;

  rmt_config(&config);
  rmt_driver_install(config.channel, 0, 0);
}
{% endhighlight %}

上面的源码定义（为了设置RMT所需的）`rmt_config_t`结构体的字段中最重要是`channel`、`gpio_num`、`mem_block_num`、`clk_div`，其他字段应该是简单地了解的。ESP32提供7个独立RMT channels，每一个RMT channel都可以采用不一样的参数，当然需要采用不一样的输出、不一样的`mem_block_num`。最后一个参数——`clk_div`——定义如何从RMT时钟源来取得RMT channel的时钟，RMT channel的时钟源频率相当$$80MHz/clk_div$$，也就是说定义最短一段时间被其RMT channel支持的。我们使用的`clk_div = 1`所定义是其RMT channel的时钟源相当RMT时钟源，因此最短一段时间等于$$12.5ns$$。我们终于可以实现传送跟着2812的协议的代码，该代码只需要构建合适`rmt_item32_t`对象，然后调用`rmt_write_items`即可。`rmt_item32_t`结构体所定义是被传送的信号，该结构体包含四个字段：`duration0`、`level0`、`duration1`、`level1`，如下面图所示。

<!--
{signal: [
  {name: '时钟源', wave: 'p.|....|......'},
  {},
  {name: '"0"',  wave: 'd1.0........dd', data:['level0', 'level1']},
  {               node: ' A B        C'},
  {},
  {name: '"1"',  wave: 'd1........0.dd', data:['level0', 'level1']},
  {               node: ' E        F G'},
  {},
  ],
  edge: ['A<~>B duration0', 'B<->C duration1', 'E<->F duration 0', 'F<->G duration1']
}
-->
![2812数据传输2](/assets/2019-12-01-esp-idf-4/rmt_item32_t.svg)

随着`clk_div`值可以计算`duration0`和`duration1`分别应该是`10`与`80`；即10个与80个时钟源脉冲，在时间定义域分别是$$125ns$$与$$1000ns$$。当然还剩下考虑复位信号的参数，随着一样的算法可以看出复位信号中的`duration0`和`duration1`二者应该是$$50000ns / 12.5 / 2 = 2000$$。（请注意：每一个`rmt_item32_t`所定义是两个脉冲，然而二者`duration`参数必须大于0；因此我们最好把复位信号除以2，而设定二者`level`等于0。）

{% highlight c++ linenos %}
const uint32_t ds = 10;
const uint32_t dl = 80;
const uint32_t rs = 2000;
const rmt_item32_t reset = { { {rs, 0, rs, 0} } };
const rmt_item32_t bit0  = { { {ds, 1, dl, 0} } };
const rmt_item32_t bit1  = { { {dl, 1, ds, 0} } };
{% endhighlight %}


{% highlight c++ linenos %}
void ws2812_rmt::operator<<(const std::vector<rgb_t> &items) const {
  std::vector<rmt_item32_t> rmt_items;
  rmt_items.emplace_back(reset);
  for (const auto &item : items) {
    colour_to_rmt(item.g, rmt_items);
    colour_to_rmt(item.r, rmt_items);
    colour_to_rmt(item.b, rmt_items);
  }
  rmt_write_items(this->channel, 
                  rmt_items.data(), 
                  rmt_items.size(), 
                  true);
}
{% endhighlight %}


# 下一次
下一次，我们来探索如何利用（硬件）串行接口为了建构一个包含GSM配件的项目，该项目是被一般（古老，我们知道！）短信控制的。同时去买一个SIM卡把，再加考虑是否你有适合电源：我们会使用SIM 800L元件，可是它需要提供$$3.7-4.0V @ 2A$$的电源！基本上有两个选择：要么加上一个独立GSM元件，然后使用一个buck变换器（linear变换器的效率很低，因此它们不会提供这么高电流），要么把ESP32换成一个USB-C、包含SIM元件的。
