---
layout: post
title:  "函数式到底好不好用？"
date:   2020-02-20 15:00:00 +0000
categories: [SW]
excerpt: "******"
hidden: true
---
我们常常听人说“命令式代码不好读，不好用，不流行，真是太糟糕了！” 只好使用函数式语言，才能够写最典雅的，最简洁的代码。” 听到这里你们一定在想世界上没有那么简单的答案，而且更仔细的想法会显示函数式语言的世界比命令式代码的世界一样复杂。不仅如此，在Tiobe最流行编程语言的榜单第二位置是C，古老的C！究竟函数式语言有什么好处？

我们不能这么问，应该这样问：“为了实现最可靠的，最可维持的代码该怎么办？” 换句话说，最常遇到的问题是什么？首先，需要仔细地定义“问题”究竟意味着什么。最简单的定义“问题”便是非即及时响应的情况。

很合适的定义是[反应式宣言](https://www.reactivemanifesto.org/zh-CN)中的_即时响应性_和_回弹性_（真的？）


本文只会讨论服务端或者后端的系统。。。

# 意外输入、意外状态、意外外在的因素
在我的经历上，我觉得最常遇到的问题来自于意外的输入，意外的状态、意外的外在因素；逻辑的后者算法的问题比前者罕见，而且逻辑或者算法问题比较容易地发现，容易地测试，调试。仔细地讲该问题以前，看下面的代码吧。

{% highlight scala %}
final case class DenseDataset(xs: Array[Double], ys: Array[Double]) {
  assert(xs.length == ys.length)
}

def calculateYoungModulus(data: DenseDataset): Double 
def loadData(experimentId: ExperimentId): DenseDataset
{% endhighlight %}

即使这两个函数缺乏实现，我们还本能地知道`loadData`函数，虽然比`calculateYoungModulus`一定更容易，但是一定更”危险“。为什么呢？虽然我们英译得清楚，可是在一般情况下，`loadData`会依靠其他系统（比如某些数据库、某些文件，总之外在、无法控制的数据输入），而且即使外在系统完全可靠，`loadData`还无法保证`experimentId`是存不存在。再加时间，特别是该时间内的系统后者数据结构体的更新。突然`loadData`不仅仅需要管理外在系统的所有问题，而且还需要管理数的据兼容或变换。这些挑战虽然不特别复杂，但源码行数越多问题也越多。不仅如此，`loadData`的类型把这些问题完全无视，看该函数的类型我们无法知道怎它会么办理意外情况。如果`experimentId`不存在，它返回`null`吗？如果`experimentId`是存在的，可是数据的格式无法转换，它还返回`null`吗？如果数据库链接被破坏了，它还是返回`null`的吗？

# 避免不确定性
我们写的代码最好避免不确定性：不确定性在用户看来。。。函数式语言雨来应用透明来避免不确定，命令式语言依赖严格顺利来避免不确定性。与命令式语言不同的是，引用透明式、函数式的语言避免另外一个不确定性的根源：（可变的）状态。

## 引用透明
引用透明意味着把函数的调用代替该函数的内部代码后，程序的语义仍然一样。引用透明的最重要的结果是函数千万不能包括直接执行的副作用；换句话说，引用透明的程序只能使用纯函数；数学的意思的“纯函数”：函数的返回值只能够依赖该函数的参数。举例子，如果`def foo(): Int`函数是纯函数，他的返回值必定是一个常数。再考虑吧：`def foo(): Int`没有参数，随着纯函数的定义——纯函数的返回值只能够依赖参数——可见没有参数的函数无法返回非常数。下一个内涵，下一个特性就是能够把纯函数的返回值存贮在缓存里；更抽象地说，每一个纯函数能够被代替与一般`map`，与此同时，每一个`map`能够被代替与一个纯函数。纯函数只是把输入映射输出，千万不包括其他副作用。

{% highlight scala %}
enum Domain {
  case One
  case Two
  case Three
}

enum Codomain {
  case Red
  case Blue
}

object RT {

  import Domain._
  import Codomain._
  def m1(d: Domain): Codomain = d match {
    case One | Two => Red
    case Three => Blue
  }

  val m2: Map[Domain, Codomain] = Map(
    One -> Red, 
    Two -> Red, 
    Three -> Blue
  )

  def test(f: Domain => Codomain): Unit = {
    assert(f(One) == Red)
    assert(f(Two) == Red)
    assert(f(Three) == Blue)
  }

  def main(args: Array[String]): Unit = {
    test(m1)
    test(m2)
  }

}
{% endhighlight %}

引用透明主要结果让人清楚地了解程序的行为，因为引用透明的程序不仅仅没有内部、可变的状态，而且程序中的函数没有任何副作用。

# 什么是副作用？
大可惜的是唯一个原因来编写一个应用就是为了它的副作用。甚至连最聪明、最复杂的纯函数无法影响外面的世界，因为为了影响外面的世界，该函数需要执行一种副作用。经典的例子，经典的玩笑就是`def foo(): Int = { launchNuclearMissiles(); 42 }`，虽然从外面看`def foo(): Int`好像是纯的函数，实现却包括一个“副作用”，即`launchNuclearMissiles()`。

那么，副作用主要点是什么？回想第一句话：我们的最终目的是避免不确定性，我们知道命令式代码依赖”一行一行”地进行的方法来表达该顺序。一步一步地进行的方法难以把计算分布，parallelise。


对比命令式和函数式
